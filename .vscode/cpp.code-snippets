{
    "chromatic.cpp": {
        "prefix": "chromatic.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "std::vector<int> vertex_coloring(std::vector<std::vector<bool>> &adj){",
            "\tint n = adj.size();",
            "\tstd::vector<int> dp(1<<n, 1e9);",
            "",
            "\tfor(int s=1; s<(1<<n); s++){",
            "\t\tbool ok = true;",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tif((s>>i&1)==0) continue;",
            "\t\t\tfor(int j=i+1; j<n; j++){",
            "\t\t\t\tif((s>>j&1)==0) continue;",
            "\t\t\t\tif(adj[i][j]) ok=false;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(ok){",
            "\t\t\tdp[s] = 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfor(int t=(s-1)&s; t>0; t=(t-1)&s){",
            "\t\t\tint u=s^t;",
            "\t\t\tdp[s] = std::min(dp[s], dp[u]+dp[t]);",
            "\t\t}",
            "\t}",
            "",
            "\tstd::vector<int> c(n, -1);",
            "\tint k=0;",
            "\tstd::queue<long long> que;",
            "\tque.push((1<<n)-1);",
            "\twhile(!que.empty()){",
            "\t\tlong long s = que.front();",
            "\t\tque.pop();",
            "",
            "\t\tbool ok = true;",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tif((s>>i&1)==0) continue;",
            "\t\t\tfor(int j=i+1; j<n; j++){",
            "\t\t\t\tif((s>>j&1)==0) continue;",
            "\t\t\t\tif(adj[i][j]) ok = false;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tif(ok){",
            "\t\t\tfor(int i=0; i<n; i++){",
            "\t\t\t\tif((s>>i&1)==0) continue;",
            "\t\t\t\tc[i] = k;",
            "\t\t\t}",
            "\t\t\tk++;",
            "\t\t\tcontinue;",
            "\t\t}",
            "",
            "\t\tfor(int t=(s-1)&s; t>0; t=(t-1)&s){",
            "\t\t\tint u = s^t;",
            "\t\t\tif(dp[s]==dp[u]+dp[t]){",
            "\t\t\t\tque.push(u);",
            "\t\t\t\tque.push(t);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\treturn c;",
            "}",
            "",
            "int chromatic_number(std::vector<std::vector<bool>> &adj){",
            "\tstd::vector<int> color = vertex_coloring(adj);",
            "\treturn *std::max_element(color.begin(), color.end())+1;",
            "}"
        ],
        "description": "cpp/chromatic.cpp"
    },
    "dijkstra.cpp": {
        "prefix": "dijkstra.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "std::vector<long long> dijkstra(int s, std::vector<std::vector<std::pair<int, long long>>> &g){",
            "    int n = g.size();",
            "    std::vector<long long> dist(n, 1e9);",
            "    dist[s] = 0;",
            "    using Pli = std::pair<long long, int>;",
            "    std::priority_queue<Pli, std::vector<Pli>, std::greater<Pli>> que;",
            "    que.push({0, s});",
            "",
            "    while(que.size()){",
            "        int u = que.top().second;",
            "        long long d = que.top().first;",
            "        que.pop();",
            "",
            "        if(d > dist[u]) continue;",
            "",
            "        for(auto p: g[u]){",
            "            int v = p.first;",
            "            long long dv = dist[u] + p.second;",
            "            if(dv < dist[v]){",
            "                dist[v] = dv;",
            "                que.push({dv, v});",
            "            }",
            "        }",
            "    }",
            "",
            "    return dist;",
            "}"
        ],
        "description": "cpp/dijkstra.cpp"
    },
    "scc.cpp": {
        "prefix": "scc.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "// perform strongly connected component decomposition",
            "class SCC{",
            "\tstd::vector<bool> visited;",
            "\tstd::vector<std::vector<int> > rev_graph;",
            "\tstd::vector<int> visit_nodes;",
            "\tstd::vector<int> root;",
            "\t// sort nodes by post-order of dfs",
            "\tvoid visit(int n){",
            "\t\tif(visited[n]) return;",
            "\t\tvisited[n] = true;",
            "\t\tfor(int i=0; i<graph[n].size(); i++){",
            "\t\t\tvisit(graph[n][i]);",
            "\t\t}",
            "\t\tvisit_nodes.push_back(n);",
            "\t}",
            "",
            "\t// assign component index",
            "\tvoid assign(int n, int r){",
            "\t\tif(root[n] >= 0) return;",
            "\t\troot[n] = r;",
            "\t\tfor(int i=0; i<rev_graph[n].size(); i++){",
            "\t\t\tassign(rev_graph[n][i], r);",
            "\t\t}",
            "\t}",
            "",
            "public:",
            "\tint n;",
            "\tstd::vector<std::vector<int> > graph; // original graph",
            "\tstd::vector<std::vector<int> > components; // nodes lists for each components",
            "\tstd::vector<int> component_index; // index of component to which each node belongs",
            "\tstd::vector<std::vector<int> > component_graph; // graph of component index",
            "",
            "\tSCC(std::vector<std::vector<int> > &g): graph(g), n(g.size()){",
            "\t\trev_graph.assign(n, {});",
            "",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tfor(int j=0; j<g[i].size(); j++){",
            "\t\t\t\trev_graph[g[i][j]].push_back(i);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tvisited.assign(n, false);",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tvisit(i);",
            "\t\t}",
            "",
            "\t\troot.assign(n, -1);",
            "\t\tfor(int i=n-1; i>=0; i--){",
            "\t\t\tint m = visit_nodes[i];",
            "\t\t\tassign(m, m);",
            "\t\t}",
            "",
            "\t\tstd::map<int, std::vector<int> > root_index;",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\troot_index[root[i]].push_back(i);",
            "\t\t}",
            "",
            "\t\tfor(auto i=root_index.begin(); i!=root_index.end(); i++){",
            "\t\t\tcomponents.push_back(i->second);",
            "\t\t}",
            "",
            "\t\tcomponent_index.assign(g.size(), 0);",
            "\t\tfor(int i=0; i<components.size(); i++){",
            "\t\t\tfor(int j=0; j<components[i].size(); j++){",
            "\t\t\t\tcomponent_index[components[i][j]] = i;",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tcomponent_graph.assign(components.size(), {});",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tfor(int j=0; j<g[i].size(); j++){",
            "\t\t\t\tint l = component_index[i];",
            "\t\t\t\tint m = component_index[g[i][j]];",
            "\t\t\t\tif(l == m) continue;",
            "\t\t\t\tcomponent_graph[l].push_back(m);",
            "\t\t\t}",
            "\t\t}",
            "",
            "\t\tfor(int i=0; i<components.size(); i++){",
            "\t\t\tsort(component_graph[i].begin(), component_graph[i].end());",
            "\t\t\tauto last = unique(component_graph[i].begin(), component_graph[i].end());",
            "\t\t\tcomponent_graph[i].resize(last - component_graph[i].begin());",
            "\t\t}",
            "\t}",
            "",
            "};",
            "",
            "int main(){",
            "\tusing namespace std;",
            "/*",
            " * 0 -> 1 -> 2 -> 7  8 -> 9",
            " * ^    |    |    ^",
            " * |    V    V    V",
            " * 3 <- 4 -> 5 -> 6",
            " */",
            "\tvector<vector<int> > g(10, vector<int>());",
            "\tg[0].push_back(1);",
            "\tg[1].push_back(2);",
            "\tg[1].push_back(4);",
            "\tg[2].push_back(5);",
            "\tg[2].push_back(7);",
            "\tg[3].push_back(0);",
            "\tg[4].push_back(3);",
            "\tg[4].push_back(5);",
            "\tg[5].push_back(6);",
            "\tg[6].push_back(7);",
            "\tg[7].push_back(6);",
            "\tg[8].push_back(9);",
            "\tSCC scc(g);",
            "",
            "\tassert(scc.component_index[0] == scc.component_index[1]);",
            "\tassert(scc.component_index[0] == scc.component_index[3]);",
            "\tassert(scc.component_index[0] == scc.component_index[4]);",
            "\tassert(scc.component_index[0] != scc.component_index[2]);",
            "\tassert(scc.component_index[2] != scc.component_index[5]);",
            "\tassert(scc.component_index[2] != scc.component_index[6]);",
            "\tassert(scc.component_index[6] == scc.component_index[7]);",
            "\tassert(scc.component_index[7] != scc.component_index[8]);",
            "\tassert(scc.component_index[8] != scc.component_index[9]);",
            "",
            "\tint c0 = scc.component_index[0];",
            "\tint c2 = scc.component_index[2];",
            "\tint c5 = scc.component_index[5];",
            "\tint c6 = scc.component_index[6];",
            "\tint c8 = scc.component_index[8];",
            "\tint c9 = scc.component_index[9];",
            "",
            "\tassert((scc.component_graph[c0] == vector<int>{c2, c5}));",
            "\tassert((scc.component_graph[c2] == vector<int>{c5, c6}));",
            "\tassert((scc.component_graph[c5] == vector<int>{c6}));",
            "\tassert((scc.component_graph[c6] == vector<int>{}));",
            "\tassert((scc.component_graph[c8] == vector<int>{c9}));",
            "\tassert((scc.component_graph[c9] == vector<int>{}));",
            "",
            "\treturn 0;",
            "}"
        ],
        "description": "cpp/scc.cpp"
    },
    "template.cpp": {
        "prefix": "template.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "",
            "template<typename T>",
            "ostream& operator<<(ostream &os, vector<T> &v){",
            "\tstring sep = \" \";",
            "\tif(v.size()) os << v[0];",
            "\tfor(int i=1; i<v.size(); i++) os << sep << v[i];",
            "\treturn os;",
            "}",
            "",
            "template<typename T>",
            "istream& operator>>(istream &is, vector<T> &v){",
            "\tfor(int i=0; i<v.size(); i++) is >> v[i];",
            "\treturn is;",
            "}",
            "",
            "#ifdef DBG",
            "void debug_(){ cout << endl; }",
            "template<typename T, typename... Args>",
            "void debug_(T&& x, Args&&... xs){",
            "\tcout << x << \" \"; debug_(forward<Args>(xs)...);",
            "}",
            "#define dbg(...) debug_(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif",
            "",
            "int main() {",
            "\tios_base::sync_with_stdio(false);",
            "\tcout << setprecision(20) << fixed;",
            "\treturn 0;",
            "}"
        ],
        "description": "cpp/template.cpp"
    },
    "rational.cpp": {
        "prefix": "rational.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "struct rational {",
            "\ttypedef long long ll;",
            "\tll d, n;",
            "\trational(ll denominator=0, ll nominator=1){",
            "\t\td = denominator;",
            "\t\tn = nominator;",
            "\t\tif(d == 0) n = 1;",
            "\t\telse {",
            "\t\t\tll g = gcd(abs(d), abs(n));",
            "\t\t\td /= g; n /= g;",
            "\t\t}",
            "",
            "\t\tif(n<0){ d=-d; n=-n; }",
            "\t}",
            "\trational(std::pair<ll, ll> p): rational(p.first, p.second) {}",
            "\t// Caution: overflow",
            "\tbool operator< (const rational &o) const {",
            "\t\treturn d*o.n<n*o.d;",
            "\t\t//return double(*this)<double(o);",
            "\t}",
            "\tbool operator== (const rational &o) const { return d==o.d&&n==o.n; }",
            "\trational inv() const { return rational(n, d); }",
            "\trational operator- () const { return rational(-d, n); }",
            "\toperator double() const { return (double)d/n; }",
            "\toperator std::pair<ll, ll>() const {return {d, n};}",
            "\tll gcd(ll x, ll y){",
            "\t\tif(y==0) return x;",
            "\t\telse return gcd(y, x%y);",
            "\t}",
            "};"
        ],
        "description": "cpp/rational.cpp"
    },
    "geometry.cpp": {
        "prefix": "geometry.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "template<typename T>",
            "struct Point {",
            "\tT x, y;",
            "\tPoint(T x=0, T y=0):x(x), y(y) {}",
            "\tPoint(std::pair<T, T> p): x(p.first), y(p.second) {}",
            "\tPoint& operator+= (const Point &o){ x += o.x; y += o.y; return *this; }",
            "\tfriend Point operator+ (Point x, const Point &y) { x += y; return x; }",
            "\tPoint& operator-= (const Point &o){ x -= o.x; y -= o.y; return *this; }",
            "\tfriend Point operator- (Point x, const Point &y) { x -= y; return x; }",
            "\tPoint& operator*= (const T &a) { x *= a, y *= a; return *this; }",
            "\tfriend Point operator* (const T a, Point x) { x *= a; return x; }",
            "\tPoint& operator/= (const T &a) { x /= a, y /= a; return *this; }",
            "\tfriend Point operator/ (Point x, const T a) { x /= a; return x; }",
            "\tT dot(const Point &o) const { return x*o.x+y*o.y; }",
            "\tT det(const Point &o){ return x*o.y-y*o.x; }",
            "\t// complex product",
            "\tPoint cp(const Point &o) {",
            "\t\tstd::complex<T> p = std::complex<T>(x, y) * std::complex<T>(o.x, o.y);",
            "\t\treturn Point(p.real(), p.imag());",
            "\t}",
            "\tbool operator< (const Point &o) { return x<o.x || (x==o.x && y<o.y); };",
            "};",
            "",
            "template<typename T>",
            "std::ostream& operator<<(std::ostream &os, Point<T> &p){",
            "    os << \"(\" << p.x << \", \" << p.y << \")\";",
            "    return os;",
            "}",
            "",
            "typedef Point<long long> PLL;",
            "std::vector<PLL> convex_hull(std::vector<PLL> &points){",
            "\tint n = points.size();",
            "\tstd::sort(points.begin(), points.end());",
            "\tstd::vector<PLL> lower(n), upper(n);",
            "\tint l = 0, r = 0;",
            "\tfor(auto p: points){",
            "\t\twhile(l>1 && (lower[l-1]-lower[l-2]).det(p-lower[l-1]) <= 0) l--;",
            "\t\tlower[l++] = p;",
            "\t}",
            "",
            "\tfor(int j=points.size()-1; j>=0; j--){",
            "\t\tauto p = points[j];",
            "\t\twhile(r>1 && (upper[r-1]-upper[r-2]).det(p-upper[r-1]) <= 0) r--;",
            "\t\tupper[r++] = p;",
            "\t}",
            "",
            "\tfor(int j=1; j<r-1; j++) lower[l++] = upper[j];",
            "\tlower.resize(l);",
            "",
            "\treturn lower;",
            "}",
            "",
            "typedef Point<double> P;",
            "double dist2(P a, P b){",
            "\treturn (a-b).dot(a-b);",
            "}",
            "",
            "// \u5916\u5fc3, not tested well",
            "P circumcenter(P a, P b, P c){",
            "\tdouble x = dist2(b, c);",
            "\tdouble y = dist2(a, c);",
            "\tdouble z = dist2(a, b);",
            "",
            "\tdouble p = x*(y+z-x);",
            "\tdouble q = y*(x+z-y);",
            "\tdouble r = z*(y+x-z);",
            "",
            "\tif(p+q+r < 1e-5){",
            "\t\tif(x >= y && x >= z){",
            "\t\t\treturn 0.5 * (b + c);",
            "\t\t} else if(y >= x && y >= z){",
            "\t\t\treturn 0.5 * (a + c);",
            "\t\t} else {",
            "\t\t\treturn 0.5 * (a + b);",
            "\t\t}",
            "\t} else {",
            "\t\treturn (p*a + q*b + r*c) / (p + q + r);",
            "\t}",
            "}",
            "",
            "std::vector<P> circles_intersections(P x1, double r1, P x2, double r2){",
            "\tP z = x2-x1;",
            "\tdouble d2 = dist2(z, P());",
            "\tdouble a = (d2 + r1*r1 - r2*r2)/2;",
            "\tdouble b2 = d2 * r1*r1 - a*a;",
            "\tdouble c = d2;",
            "\tif(abs(b2) < 1e-10){",
            "\t\treturn {P(a * z.x / c, a * z.y / c) + x1};",
            "\t}",
            "\tif(b2 < 0) return std::vector<P>();",
            "",
            "\tdouble b = sqrt(b2);",
            "\treturn {P((a * z.x + z.y * b) / c,",
            "\t\t\t  (a * z.y - z.x * b) / c) + x1,",
            "\t\t   P((a * z.x - z.y * b) / c,",
            "\t\t\t (a * z.y + z.x * b) / c) + x1};",
            "}"
        ],
        "description": "cpp/geometry.cpp"
    },
    "lca.cpp": {
        "prefix": "lca.cpp",
        "scope": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "template<typename T = long long>",
            "struct LCA {",
            "\tint n, l, root=-1;",
            "\tstd::vector<std::vector<std::pair<int, T>>> graph;",
            "\tstd::vector<int> dep;",
            "\tstd::vector<T> dist;",
            "\tstd::vector<std::vector<int>> par;",
            "\tstd::vector<std::vector<T>> max_edges;",
            "\tLCA(int n) : n(n) {",
            "\t\tl = 0;",
            "\t\twhile ((1 << l) < n) l++;",
            "\t\tgraph.assign(n, {});",
            "\t\tdist.assign(n, 0);",
            "\t\tdep.assign(n, 0);",
            "\t\tpar.assign(n, vector<int>(l, -1));",
            "\t\tmax_edges.assign(n, vector<T>(l));",
            "\t}",
            "\tvoid add_edge(int u, int v, T c = 0) {",
            "\t\tgraph[u].emplace_back(v, c);",
            "\t\tgraph[v].emplace_back(u, c);",
            "\t}",
            "\tvoid init(int _root = 0) {",
            "\t\troot = _root;",
            "\t\tdfs(root, -1, 0, 0);",
            "\t\tfor (int i=1; i<l; i++) {",
            "\t\t\tfor (int u=0; u<n; u++) {",
            "\t\t\t\tif (par[u][i-1] < 0) continue;",
            "\t\t\t\tpar[u][i] = par[par[u][i-1]][i-1];",
            "\t\t\t\tmax_edges[u][i] = std::max(max_edges[u][i-1], max_edges[par[u][i-1]][i-1]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid dfs(int u, int p, T c, int d) {",
            "\t\tdist[u] = c;",
            "\t\tpar[u][0] = p;",
            "\t\tdep[u] = d;",
            "\t\tfor (auto e : graph[u]) {",
            "\t\t\tint v = e.first;",
            "\t\t\tT cv = e.second;",
            "\t\t\tif (v==p) continue;",
            "\t\t\tmax_edges[v][0] = cv;",
            "\t\t\tdfs(v, u, c+cv, d+1);",
            "\t\t}",
            "\t}",
            "\tint operator() (int u, int v) const {",
            "\t\tassert(root>=0); // check whether inited",
            "\t\tif (dep[u]<dep[v]) swap(u, v);",
            "\t\tint gap = dep[u]-dep[v];",
            "\t\tfor (int i=0; i<l; i++) {",
            "\t\t\tif (gap & (1 << i)) u = par[u][i];",
            "\t\t}",
            "\t\tif (u==v) return u;",
            "\t\tfor (int i=l-1; i>=0; i--) {",
            "\t\t\tif (par[u][i]!=par[v][i]) {",
            "\t\t\t\tu = par[u][i];",
            "\t\t\t\tv = par[v][i];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn par[u][0];",
            "\t}",
            "\tT distance(int u, int v) const {",
            "\t\tint c = (*this)(u, v);",
            "\t\tif(c < 0) return -1; // when graph is not connected",
            "\t\treturn dist[u]+dist[v]-2*dist[c];",
            "\t}",
            "\tT max_edge(int from, int to) const {",
            "\t\t// maximum edge between from and to",
            "\t\t// https://atcoder.jp/contests/past202004-open/submissions/13002791",
            "\t\tassert(root>=0); // check whether inited",
            "\t\tint u = from;",
            "\t\tT x = 0;",
            "\t\tfor(int i=l-1; i>=0; i--){",
            "\t\t\tif(par[u][i]<0) continue;",
            "\t\t\tif(dep[par[u][i]]>=dep[to]){",
            "\t\t\t\tx = std::max(x, max_edges[u][i]);",
            "\t\t\t\tu = par[u][i];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn x;",
            "\t}",
            "};"
        ],
        "description": "cpp/lca.cpp"
    },
    "min_cost_flow.cpp": {
        "prefix": "min_cost_flow.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "template <class Cap = int, class Cost = long long> struct MinCostFlow {",
            "  public:",
            "    MinCostFlow() {}",
            "    MinCostFlow(int n) : _n(n), g(n) {}",
            "",
            "    int add_edge(int from, int to, Cap cap, Cost cost) {",
            "        assert(0 <= from && from < _n);",
            "        assert(0 <= to && to < _n);",
            "        assert(0 <= cap);",
            "        assert(0 <= cost);",
            "        int m = int(pos.size());",
            "        pos.push_back({from, int(g[from].size())});",
            "        int from_id = int(g[from].size());",
            "        int to_id = int(g[to].size());",
            "        if (from == to) to_id++;",
            "        g[from].push_back(_edge{to, to_id, cap, cost});",
            "        g[to].push_back(_edge{from, from_id, 0, -cost});",
            "        return m;",
            "    }",
            "",
            "    struct edge {",
            "        int from, to;",
            "        Cap cap, flow;",
            "        Cost cost;",
            "    };",
            "",
            "    edge get_edge(int i) {",
            "        int m = int(pos.size());",
            "        assert(0 <= i && i < m);",
            "        auto _e = g[pos[i].first][pos[i].second];",
            "        auto _re = g[_e.to][_e.rev];",
            "        return edge{",
            "            pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,",
            "        };",
            "    }",
            "    std::vector<edge> edges() {",
            "        int m = int(pos.size());",
            "        std::vector<edge> result(m);",
            "        for (int i = 0; i < m; i++) {",
            "            result[i] = get_edge(i);",
            "        }",
            "        return result;",
            "    }",
            "",
            "    std::pair<Cap, Cost> flow(int s, int t) {",
            "        return flow(s, t, std::numeric_limits<Cap>::max());",
            "    }",
            "    std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {",
            "        return slope(s, t, flow_limit).back();",
            "    }",
            "    std::vector<std::pair<Cap, Cost>> slope(int s, int t) {",
            "        return slope(s, t, std::numeric_limits<Cap>::max());",
            "    }",
            "    std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {",
            "        assert(0 <= s && s < _n);",
            "        assert(0 <= t && t < _n);",
            "        assert(s != t);",
            "        // variants (C = maxcost):",
            "        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0",
            "        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge",
            "        std::vector<Cost> dual(_n, 0), dist(_n);",
            "        std::vector<int> pv(_n), pe(_n);",
            "        std::vector<bool> vis(_n);",
            "        auto dual_ref = [&]() {",
            "            std::fill(dist.begin(), dist.end(),",
            "                      std::numeric_limits<Cost>::max());",
            "            std::fill(pv.begin(), pv.end(), -1);",
            "            std::fill(pe.begin(), pe.end(), -1);",
            "            std::fill(vis.begin(), vis.end(), false);",
            "            struct Q {",
            "                Cost key;",
            "                int to;",
            "                bool operator<(Q r) const { return key > r.key; }",
            "            };",
            "            std::priority_queue<Q> que;",
            "            dist[s] = 0;",
            "            que.push(Q{0, s});",
            "            while (!que.empty()) {",
            "                int v = que.top().to;",
            "                que.pop();",
            "                if (vis[v]) continue;",
            "                vis[v] = true;",
            "                if (v == t) break;",
            "                // dist[v] = shortest(s, v) + dual[s] - dual[v]",
            "                // dist[v] >= 0 (all reduced cost are positive)",
            "                // dist[v] <= (n-1)C",
            "                for (int i = 0; i < int(g[v].size()); i++) {",
            "                    auto e = g[v][i];",
            "                    if (vis[e.to] || !e.cap) continue;",
            "                    // |-dual[e.to] + dual[v]| <= (n-1)C",
            "                    // cost <= C - -(n-1)C + 0 = nC",
            "                    Cost cost = e.cost - dual[e.to] + dual[v];",
            "                    if (dist[e.to] - dist[v] > cost) {",
            "                        dist[e.to] = dist[v] + cost;",
            "                        pv[e.to] = v;",
            "                        pe[e.to] = i;",
            "                        que.push(Q{dist[e.to], e.to});",
            "                    }",
            "                }",
            "            }",
            "            if (!vis[t]) {",
            "                return false;",
            "            }",
            "",
            "            for (int v = 0; v < _n; v++) {",
            "                if (!vis[v]) continue;",
            "                // dual[v] = dual[v] - dist[t] + dist[v]",
            "                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])",
            "                //         = - shortest(s, t) + dual[t] + shortest(s, v)",
            "                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C",
            "                dual[v] -= dist[t] - dist[v];",
            "            }",
            "            return true;",
            "        };",
            "        Cap flow = 0;",
            "        Cost cost = 0, prev_cost_per_flow = -1;",
            "        std::vector<std::pair<Cap, Cost>> result;",
            "        result.push_back({flow, cost});",
            "        while (flow < flow_limit) {",
            "            if (!dual_ref()) break;",
            "            Cap c = flow_limit - flow;",
            "            for (int v = t; v != s; v = pv[v]) {",
            "                c = std::min(c, g[pv[v]][pe[v]].cap);",
            "            }",
            "            for (int v = t; v != s; v = pv[v]) {",
            "                auto& e = g[pv[v]][pe[v]];",
            "                e.cap -= c;",
            "                g[v][e.rev].cap += c;",
            "            }",
            "            Cost d = -dual[s];",
            "            flow += c;",
            "            cost += c * d;",
            "            if (prev_cost_per_flow == d) {",
            "                result.pop_back();",
            "            }",
            "            result.push_back({flow, cost});",
            "            prev_cost_per_flow = d;",
            "        }",
            "        return result;",
            "    }",
            "",
            "  private:",
            "    int _n;",
            "",
            "    struct _edge {",
            "        int to, rev;",
            "        Cap cap;",
            "        Cost cost;",
            "    };",
            "",
            "    std::vector<std::pair<int, int>> pos;",
            "    std::vector<std::vector<_edge>> g;",
            "};"
        ],
        "description": "cpp/min_cost_flow.cpp"
    },
    "segment_tree.cpp": {
        "prefix": "segment_tree.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "template <typename T>",
            "struct SegmentTree{",
            "\tstd::vector<T> v;",
            "\tT def;",
            "\tint n;",
            "\tSegmentTree(int n_, T default_value): def(default_value){",
            "\t\tn = 1;",
            "\t\twhile(n<n_) n <<= 1;",
            "\t\tv.assign(2*n-1, def);",
            "\t}",
            "\ttemplate<class I>",
            "\tSegmentTree(I first, I last, T default_value): SegmentTree(last-first, default_value){",
            "\t\tcopy(first, last, v.begin()+n-1);",
            "\t\tfor(int i=n-2; i>=0; i--)",
            "\t\t\tv[i] = merge(v[2*i+1], v[2*i+2]);",
            "\t}",
            "\tSegmentTree(std::vector<T> initial_data, T default_value):",
            "\tSegmentTree(initial_data.begin(), initial_data.end(), default_value){}",
            "\t// 0 <= idx < n",
            "\tvoid update(int idx, T val){",
            "\t\tidx += n-1;",
            "\t\tv[idx] = val;",
            "\t\twhile(idx > 0){",
            "\t\t\tidx = (idx-1)/2;",
            "\t\t\tv[idx] = merge(v[2*idx+1], v[2*idx+2]);",
            "\t\t}",
            "\t}",
            "\tT q(int a, int b, int k, int l, int r){",
            "\t\tif(a<=l&&r<=b) return v[k];",
            "\t\tif(b<=l||r<=a) return def;",
            "\t\treturn merge(q(a, b, 2*k+1, l, (l+r)/2), q(a, b, 2*k+2, (l+r)/2, r));",
            "\t}",
            "\t// 0 <= a < b < n",
            "\tT query(int a, int b){",
            "\t\treturn q(a, b, 0, 0, n);",
            "\t}",
            "\tT merge(T left, T right);",
            "};",
            "",
            "// Example",
            "",
            "template <typename T>",
            "T SegmentTree<T>::merge(T a, T b){",
            "\treturn std::min(a, b);",
            "}"
        ],
        "description": "cpp/segment_tree.cpp"
    },
    "math.cpp": {
        "prefix": "math.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "// @param n `0 <= n <= 1e9`",
            "// @param m `1 <= m <= 1e9`",
            "// @param a `0 <= a`",
            "// @param b `0 <= b`",
            "// @return \\sum_{i=0}^{n-1} floor((a*i+b)/m)",
            "long long floor_sum(long long n, long long m, long long a, long long b) {",
            "    long long ans = 0;",
            "    if (a >= m) {",
            "        ans += (n - 1) * n * (a / m) / 2;",
            "        a %= m;",
            "    }",
            "    if (b >= m) {",
            "        ans += n * (b / m);",
            "        b %= m;",
            "    }",
            "",
            "    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);",
            "    if (y_max == 0) return ans;",
            "    ans += (n - (x_max + a - 1) / a) * y_max;",
            "    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);",
            "    return ans;",
            "}",
            "",
            "// @param b `1 <= b`",
            "// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "    a = (a%b+b)%b;",
            "    if (a == 0) return {b, 0};",
            "",
            "    // Contracts:",
            "    // [1] s - m0 * a = 0 (mod b)",
            "    // [2] t - m1 * a = 0 (mod b)",
            "    // [3] s * |m1| + t * |m0| <= b",
            "    long long s = b, t = a;",
            "    long long m0 = 0, m1 = 1;",
            "",
            "    while (t) {",
            "        long long u = s / t;",
            "        s -= t * u;",
            "        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b",
            "",
            "        // [3]:",
            "        // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "        // = s * |m1| + t * |m0| <= b",
            "",
            "        auto tmp = s;",
            "        s = t;",
            "        t = tmp;",
            "        tmp = m0;",
            "        m0 = m1;",
            "        m1 = tmp;",
            "    }",
            "    // by [3]: |m0| <= b/g",
            "    // by g != b: |m0| < b/g",
            "    if (m0 < 0) m0 += b / s;",
            "    return {s, m0};",
            "}",
            "",
            "// (rem, mod)",
            "std::pair<long long, long long> crt(const std::vector<long long>& r,",
            "                                    const std::vector<long long>& m) {",
            "    assert(r.size() == m.size());",
            "    int n = int(r.size());",
            "    // Contracts: 0 <= r0 < m0",
            "    long long r0 = 0, m0 = 1;",
            "    for (int i = 0; i < n; i++) {",
            "        assert(1 <= m[i]);",
            "        long long m1 = m[i];",
            "        long long r1 = (r[i]%m1+m1)%m1;",
            "        if (m0 < m1) {",
            "            std::swap(r0, r1);",
            "            std::swap(m0, m1);",
            "        }",
            "        if (m0 % m1 == 0) {",
            "            if (r0 % m1 != r1) return {0, 0};",
            "            continue;",
            "        }",
            "        // assume: m0 > m1, lcm(m0, m1) >= 2 * max(m0, m1)",
            "",
            "        // (r0, m0), (r1, m1) -> (r2, m2 = lcm(m0, m1));",
            "        // r2 % m0 = r0",
            "        // r2 % m1 = r1",
            "        // -> (r0 + x*m0) % m1 = r1",
            "        // -> x*u0*g % (u1*g) = (r1 - r0) (u0*g = m0, u1*g = m1)",
            "        // -> x = (r1 - r0) / g * inv(u0) (mod u1)",
            "",
            "        // im = inv(u0) (mod u1) (0 <= im < u1)",
            "        long long g, im;",
            "        std::tie(g, im) = inv_gcd(m0, m1);",
            "",
            "        long long u1 = (m1 / g);",
            "        // |r1 - r0| < (m0 + m1) <= lcm(m0, m1)",
            "        if ((r1 - r0) % g) return {0, 0};",
            "",
            "        // u1 * u1 <= m1 * m1 / g / g <= m0 * m1 / g = lcm(m0, m1)",
            "        long long x = (r1 - r0) / g % u1 * im % u1;",
            "",
            "        // |r0| + |m0 * x|",
            "        // < m0 + m0 * (u1 - 1)",
            "        // = m0 + m0 * m1 / g - m0",
            "        // = lcm(m0, m1)",
            "        r0 += x * m0;",
            "        m0 *= u1;  // -> lcm(m0, m1)",
            "        if (r0 < 0) r0 += m0;",
            "    }",
            "    return {r0, m0};",
            "}"
        ],
        "description": "cpp/math.cpp"
    },
    "omnidirect_tree_dp.cpp": {
        "prefix": "omnidirect_tree_dp.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "struct Elem {",
            "\tElem() {}",
            "\tElem& operator+=(Elem &c) {",
            "\t\treturn *this;",
            "\t}",
            "\tElem add_self() const {",
            "\t\tElem ret(*this);",
            "\t\treturn ret;",
            "\t}",
            "\tElem operator-(Elem &o) const {",
            "\t\tElem ret(*this);",
            "\t\treturn ret;",
            "\t}",
            "};",
            "",
            "Elem dp[20005];",
            "vector<vector<int>> graph;",
            "",
            "void dfs(int u, int p){",
            "\tfor(int v: graph[u]) {",
            "\t\tif(v==p) continue;",
            "\t\tdfs(v, u);",
            "\t\tdp[u] += dp[v];",
            "\t}",
            "\tdp[u] = dp[u].add_self();",
            "}",
            "",
            "void omnidirect(int u, int p){",
            "\tElem sum;",
            "\tfor(int v: graph[u]){",
            "\t\tsum += dp[v];",
            "\t}",
            "\tfor(int v: graph[u]){",
            "\t\tif(v==p) continue;",
            "\t\tdp[u] = (sum - dp[v]).add_self();",
            "\t\tomnidirect(v, u);",
            "\t}",
            "\tdp[u] = sum.add_self();",
            "}",
            "",
            "int main() {",
            "\tdfs(0, -1);",
            "\tomnidirect(0, -1);",
            "}"
        ],
        "description": "cpp/omnidirect_tree_dp.cpp"
    },
    "trie.cpp": {
        "prefix": "trie.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "// accepts a string with lower alphabets.",
            "struct Trie {",
            "    struct Node {",
            "        std::vector<Node*> children;",
            "        std::vector<int> count;  // keep the number of suffix string containing each alphabet.",
            "        Node(int n_char){",
            "            children.assign(n_char, NULL);",
            "            count.assign(n_char, 0);",
            "        }",
            "        std::vector<bool> add(const std::string &s, int idx){",
            "            if(idx==s.size()) return std::vector<bool>(children.size());",
            "            int c = s[idx]-'a';",
            "            if(children[c] == NULL){",
            "                Node* next = new Node(children.size());",
            "                children[c] = next;",
            "            }",
            "            std::vector<bool> cnt = children[c]->add(s, idx+1);",
            "            cnt[c] = true;",
            "            for(int i=0; i<cnt.size(); i++){",
            "                if(cnt[i]) count[i]++;",
            "            }",
            "            return cnt;",
            "        }",
            "",
            "        Node* find(const std::string &s, int idx){",
            "            if(idx==s.size()) return this;",
            "            int c = s[idx]-'a';",
            "            if(children[c]==NULL){",
            "                return NULL;",
            "            }",
            "            return children[c]->find(s, idx+1);",
            "        }",
            "    };",
            "    Node* root;",
            "",
            "    Trie(int n=26) {",
            "        root = new Node(n);",
            "    }",
            "",
            "    void add(const std::string &s){",
            "        root->add(s, 0);",
            "    }",
            "",
            "    Node* find(const std::string &s){",
            "        return root->find(s, 0);",
            "    }",
            "};"
        ],
        "description": "cpp/trie.cpp"
    },
    "prime.cpp": {
        "prefix": "prime.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "struct Prime {",
            "\tstd::vector<int> sieve;",
            "\tstd::vector<int> primes;",
            "",
            "\t// Keep primes up to n_max",
            "\tPrime(int n_max) {",
            "\t\tsieve = std::vector<int>(n_max+1);",
            "\t\tfor(int i=2; i<sieve.size(); i++){",
            "\t\t\tif(sieve[i]>0) continue;",
            "\t\t\tfor(int j=2*i; j<sieve.size(); j+=i) sieve[j] = i;",
            "\t\t}",
            "\t\tfor(int i=2; i<sieve.size(); i++){",
            "\t\t\tif(sieve[i]==0) primes.push_back(i);",
            "\t\t}",
            "\t}",
            "",
            "\tstd::map<long long, int> factorize(long long x) {",
            "\t\tint m = sieve.size();",
            "\t\tassert(x <= (long long)m * m);",
            "\t\tif(x < m){",
            "\t\t\treturn factorize_fast(x);",
            "\t\t} else {",
            "\t\t\treturn factorize_naive(x);",
            "\t\t}",
            "\t}",
            "",
            "\tstd::map<long long, int> factorize_naive(long long x){",
            "\t\tstd::map<long long, int> fs;",
            "\t\tfor(int p: primes) {",
            "\t\t\tif(p*p>x) break;",
            "\t\t\twhile(x%p==0) {",
            "\t\t\t\tfs[p]++;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(x>1) fs[x]++;",
            "\t\treturn fs;",
            "\t}",
            "",
            "\tstd::map<long long, int> factorize_fast(int x){",
            "\t\tstd::map<long long, int> fs;",
            "\t\twhile(x > 1) {",
            "\t\t\tfs[sieve[x]]++;",
            "\t\t\tx /= sieve[x];",
            "\t\t}",
            "\t\treturn fs;",
            "\t}",
            "};"
        ],
        "description": "cpp/prime.cpp"
    },
    "bit.cpp": {
        "prefix": "bit.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "template <typename T>",
            "struct Bit{",
            "\tstd::vector<T> v;",
            "\tint n;",
            "\tBit(int n_): n(n_){ v.assign(n_, 0); }",
            "\t// 0 <= i < n",
            "\tT sum(int i){",
            "\t\tT s=0;",
            "\t\twhile(i>0){ s += v[i]; i -= i & -i; }",
            "\t\treturn s;",
            "\t}",
            "\t// 1 <= i < n",
            "\tvoid add(int i, T x){",
            "\t\twhile(i < n){ v[i] += x; i += i & -i; }",
            "\t}",
            "};",
            "",
            "// v: permutation of (1, ... , n)",
            "long long crossing(std::vector<int> &v){",
            "\tBit<long long> bit(v.size()+1);",
            "\tlong long count = 0;",
            "\tfor(int i=0; i<v.size(); i++){",
            "\t\tcount += i - bit.sum(v[i]);",
            "\t\tbit.add(v[i], 1);",
            "\t}",
            "\treturn count;",
            "}"
        ],
        "description": "cpp/bit.cpp"
    },
    "mod_comb.cpp": {
        "prefix": "mod_comb.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "// Extended Euclid's greatest common divisor algorithm",
            "// Find (x, y)",
            "// where",
            "//   - a*x + b*y = gcd(a, b)$",
            "long long ext_gcd(long long a, long long b, long long &x, long long &y){",
            "\tif(b == 0){",
            "\t\tx = 1; y = 0; return a;",
            "\t}",
            "\tlong long nx, ny;",
            "\tlong long g = ext_gcd(b, a%b, nx, ny);",
            "\tx = ny;",
            "\ty = nx - a / b * ny;",
            "\treturn g;",
            "}",
            "",
            "template<long long m=1000000007>",
            "struct modint {",
            "\ttypedef long long ll;",
            "\tll x;",
            "\tstatic constexpr ll mod() { return m; }",
            "\tconstexpr modint(ll x=0): x((m+x%m)%m) {}",
            "\tmodint<m> operator-() const { return modint(m-x); }",
            "\tmodint<m>& operator+=(const modint<m> o) { x=(x+o.x)%m; return *this; }",
            "\tmodint<m>& operator+=(const ll o) { return (*this)+=modint(o); }",
            "\tmodint<m>& operator-=(const modint<m> o) { return (*this)+=(-o); }",
            "\tmodint<m>& operator-=(const ll o) { return (*this)-=modint(o); }",
            "\tmodint<m>& operator*=(const modint<m> o) { x = x*o.x%m; return *this; }",
            "\tmodint<m>& operator*=(const ll o) { return (*this)*=modint(o); }",
            "\tmodint<m>& operator/=(const modint<m> o) { return (*this)*=o.inv(); }",
            "\tmodint<m>& operator/=(const ll o) { return (*this)/=modint(o); }",
            "\tfriend modint<m> operator+(modint<m> l, const modint<m> r) { l+=r; return l; }",
            "\tfriend modint<m> operator+(modint<m> l, const ll r) { l+=r; return l; }",
            "\tfriend modint<m> operator+(const ll l, modint<m> r) { r+=l; return r; }",
            "\tfriend modint<m> operator-(modint<m> l, const modint<m> r) { l-=r; return l; }",
            "\tfriend modint<m> operator-(modint<m> l, const ll r) { l-=r; return l; }",
            "\tfriend modint<m> operator-(const ll l, modint<m> r) { r*=-1; r+=l; return r; }",
            "\tfriend modint<m> operator*(modint<m> l, const modint<m> r) { l*=r; return l; }",
            "\tfriend modint<m> operator*(modint<m> l, const ll r) { l*=r; return l; }",
            "\tfriend modint<m> operator*(const ll l, modint<m> r) { r*=l; return r; }",
            "\tfriend modint<m> operator/(modint<m> l, const modint<m> r) { l/=r; return l; }",
            "\tfriend modint<m> operator/(modint<m> l, const ll r) { l/=r; return l; }",
            "\tfriend modint<m> operator/(const ll l, const modint<m> r) { return modint(l)/r; }",
            "\tbool operator==(const modint<m> o) const { return x==o.x; }",
            "\tbool operator!=(const modint<m> o) const { return x!=o.x; }",
            "\tfriend bool operator==(const ll l, const modint<m> r) { return modint<m>(l) == r; }",
            "\tfriend bool operator!=(const ll l, const modint<m> r) { return modint<m>(l) != r; }",
            "\tfriend std::ostream& operator<<(std::ostream &os, const modint<m> x) { return os << x.x; }",
            "",
            "\tmodint<m> pow(ll k) const {",
            "\t\tif(k==0) return modint<m>(1);",
            "\t\tif(k%2) return pow(k-1)*x;",
            "\t\tmodint<m> z = pow(k/2); return z*z;",
            "\t}",
            "",
            "\tmodint<m> inv() const {",
            "\t\tll y,z;",
            "\t\text_gcd(x, m, y, z);",
            "\t\treturn modint<m>(y);",
            "\t}",
            "};",
            "",
            "using mint = modint<>;",
            "",
            "template<typename mint = mint>",
            "struct Comb {",
            "\ttypedef long long ll;",
            "\tconst ll m = mint::mod();",
            "\tstd::vector<mint> fact, fact_inv;",
            "\tComb(int n_max=2000005) {",
            "\t\tfact.assign(n_max, 0);",
            "\t\tfact_inv.assign(n_max, 0);",
            "\t\tfact[0] = 1;",
            "\t\tfact_inv[0] = 1;",
            "\t\tfor(int i=1; i<std::min((ll)n_max, m); i++){",
            "\t\t\tfact[i] = fact[i-1] * i;",
            "\t\t\tfact_inv[i] = fact[i].inv();",
            "\t\t}",
            "\t}",
            "\tmint operator() (ll n, ll k) const {",
            "\t\tif(n < m){",
            "\t\t\treturn fact[n] * fact_inv[k] * fact_inv[n-k];",
            "\t\t} else {",
            "\t\t\treturn comb_ext(n, k);",
            "\t\t}",
            "\t}",
            "",
            "// Modular factorial of n, also counting p's appearance e",
            "// n! = a * p^e",
            "// return: a % p",
            "// n! = n * (n-1) * ... * (k*p+1) *",
            "//      (k*p) * (k*p-1) * ... ((k-1)*p+1) *",
            "//      ...",
            "//      p * (p-1) * ... * 2 * 1   (k = floor(n/p))",
            "//    = (n%p) * ... * 1 *",
            "//      (k*p) * (p-1) * ... * 1 *",
            "//      p * (p-1) * ... * 1       (mod p, preserving p's multiples)",
            "//    = (n%p)! * p^k * k! * (p-1)^k",
            "//    = (n%p)! * p^k * k! * (p-1)^(k%2)",
            "//",
            "// From the facts:",
            "//   (p-1)! = p-1 (mod p) (c.f. Willson's theorem)",
            "//   (p-2)**2 = 1 (mod p)",
            "\tmint fact_ext(ll n, ll &e) const {",
            "\t\tif(n == 0){",
            "\t\t\te = 0;",
            "\t\t\treturn mint(1);",
            "\t\t}",
            "",
            "\t\tmint na = fact_ext(n/m, e);",
            "\t\te += n/m;",
            "\t\tmint a = na * fact[n%m];",
            "\t\tif((n/m)%2) a = a * (m-1);",
            "\t\treturn a;",
            "\t}",
            "",
            "// Modular combination (n, m) given module p",
            "// (n, m) = n!/(n-m)!m!",
            "//        = (a_n * p^(e_n)) / ((a_{n-m} * p^(e_{n-m}) * (a_m * p^e_m))",
            "//        = a_n / (a_{n-m} * a_m) * p^(e_n - e_{n-m} - e_m)",
            "\tmint comb_ext (ll n, ll k) const {",
            "\t\tll e1,e2,e3;",
            "\t\tmint a1 = fact_ext(n, e1);",
            "\t\tmint a2 = fact_ext(k, e2);",
            "\t\tmint a3 = fact_ext(n-k, e3);",
            "",
            "\t\tif(e1 > e2+e3) return 0;",
            "\t\telse return a1*(a2*a3).inv();",
            "\t}",
            "};"
        ],
        "description": "cpp/mod_comb.cpp"
    },
    "z_algo.cpp": {
        "prefix": "z_algo.cpp",
        "scope": "cpp",
        "body": [
            "// from https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/",
            "#include<bits/stdc++.h>",
            "",
            "// Z array: Z[i] = maximum n s.t. str[0..n] == str[i..i+n]",
            "std::vector<int> getZarray(std::string &str) {",
            "\tint n = str.length();",
            "\tstd::vector<int> Z(n);",
            "\tint L, R, k;",
            "\t// [L,R] make a window which matches with prefix of s",
            "\tL = R = 0;",
            "\tfor (int i=1; i<n; i++) {",
            "\t\t// if i>R nothing matches so we will calculate.",
            "\t\t// Z[i] using naive way.",
            "\t\tif (i > R) {",
            "\t\t\tL = R = i;",
            "\t\t\t// R-L = 0 in starting, so it will start",
            "\t\t\t// checking from 0'th index. For example,",
            "\t\t\t// for \"ababab\" and i = 1, the value of R",
            "\t\t\t// remains 0 and Z[i] becomes 0. For string",
            "\t\t\t// \"aaaaaa\" and i = 1, Z[i] and R become 5",
            "\t\t\twhile (R<n && str[R-L] == str[R]) R++;",
            "\t\t\tZ[i] = R-L;",
            "\t\t\tR--;",
            "\t\t} else {",
            "\t\t\t// k = i-L so k corresponds to number which",
            "\t\t\t// matches in [L,R] interval.",
            "\t\t\tk = i-L;",
            "\t\t\t// if Z[k] is less than remaining interval",
            "\t\t\t// then Z[i] will be equal to Z[k].",
            "\t\t\t// For example, str = \"ababab\", i = 3, R = 5",
            "\t\t\t// and L = 2",
            "\t\t\tif (Z[k] < R-i+1) Z[i] = Z[k];",
            "\t\t\t// For example str = \"aaaaaa\" and i = 2, R is 5,",
            "\t\t\t// L is 0",
            "\t\t\telse {",
            "\t\t\t\t// else start from R and check manually",
            "\t\t\t\tL = i;",
            "\t\t\t\twhile (R<n && str[R-L] == str[R]) R++;",
            "\t\t\t\tZ[i] = R-L;",
            "\t\t\t\tR--;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn Z;",
            "}",
            "",
            "std::vector<int> occurance(std::string &text, std::string &pattern){",
            "\tstd::string concat = pattern + \"$\" + text;",
            "\tint np = pattern.size();",
            "\tstd::vector<int> z = getZarray(concat);",
            "\tstd::vector<int> idx;",
            "",
            "\tfor(int i=0; i<concat.size()-np-1; i++){",
            "\t\tif(z[i+np+1] >= np) idx.push_back(i);",
            "\t}",
            "\treturn idx;",
            "}",
            "",
            "int _main(){",
            "\tusing namespace std;",
            "\tstring text = \"aababaabaacaabaa\";",
            "\tstring pat = \"aab\";",
            "\tvector<int> oc = occurance(text, pat);",
            "\tassert((oc==vector<int>{0, 5, 11}));",
            "\treturn 0;",
            "}"
        ],
        "description": "cpp/z_algo.cpp"
    },
    "max_flow.cpp": {
        "prefix": "max_flow.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "class MaxFlowGraph{",
            "\tusing ll = long long;",
            "\tconst ll INF = 1e18;",
            "\tstd::vector<bool> used;",
            "\tll dfs(int v, int t, ll f){",
            "\t\tif(v == t) return f;",
            "\t\tused[v] = true;",
            "\t\tfor(int i=0; i<graph[v].size(); i++){",
            "\t\t\tedge &e = graph[v][i];",
            "\t\t\tif(!used[e.to] && e.cap > 0){",
            "\t\t\t\tll d = dfs(e.to, t, std::min(e.cap, f));",
            "\t\t\t\tif(d>0){",
            "\t\t\t\t\te.cap -= d;",
            "\t\t\t\t\tgraph[e.to][e.rev].cap += d;",
            "\t\t\t\t\treturn d;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "",
            "public:",
            "\tstruct edge {",
            "\t\tint to, rev; // destination, index for reversed edge",
            "\t\tlong long cap; // capacity",
            "\t};",
            "\tint n;",
            "\tstd::vector<std::vector<edge> > graph;",
            "\tMaxFlowGraph(int n_vertex): n(n_vertex){",
            "\t\tgraph.assign(n_vertex, {});",
            "\t}",
            "",
            "\tvoid add_edge(int from, int to, ll cap){",
            "\t\tgraph[from].push_back((edge){to, (int)graph[to].size(), cap});",
            "\t\tgraph[to].push_back((edge){from, (int)graph[from].size()-1, 0});",
            "\t}",
            "",
            "\tll flow(int s, int t){",
            "\t\tll flow = 0;",
            "\t\twhile(true){",
            "\t\t\tused.assign(n, false);",
            "\t\t\tll f = dfs(s, t, INF);",
            "\t\t\tif(f==0) return flow;",
            "\t\t\tflow += f;",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "cpp/max_flow.cpp"
    },
    "union_find.cpp": {
        "prefix": "union_find.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "struct UnionFind{",
            "\tstd::vector<int> par, rnk, cnt;",
            "\tUnionFind(int n){",
            "\t\tpar.assign(n, 0);",
            "\t\trnk.assign(n, 0);",
            "\t\tcnt.assign(n, 1);",
            "\t\tfor(int i=0; i<n; i++) par[i]=i;",
            "\t}",
            "\tint root(int i){",
            "\t\tif(par[i]==i) return i;",
            "\t\treturn par[i]=root(par[i]);",
            "\t}",
            "\tvoid unite(int i, int j){",
            "\t\tint ri = root(i);",
            "\t\tint rj = root(j);",
            "\t\tif(ri==rj) return;",
            "",
            "\t\tif(rnk[ri]==rnk[rj]){",
            "\t\t\tcnt[rj] += cnt[ri];",
            "\t\t\tpar[ri] = rj;",
            "\t\t\trnk[rj]++;",
            "\t\t}",
            "\t\telse if(rnk[ri] < rnk[rj]){",
            "\t\t\tcnt[rj] += cnt[ri];",
            "\t\t\tpar[ri] = rj;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tcnt[ri] += cnt[rj];",
            "\t\t\tpar[rj] = ri;",
            "\t\t}",
            "\t}",
            "\tbool same(int i, int j){",
            "\t\treturn root(i) == root(j);",
            "\t}",
            "\tint count(int i){",
            "\t\treturn cnt[root(i)];",
            "\t}",
            "};"
        ],
        "description": "cpp/union_find.cpp"
    },
    "lazy_segment_tree.cpp": {
        "prefix": "lazy_segment_tree.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "template <typename T, typename E>",
            "struct LazySegmentTree{",
            "\tstd::vector<T> data;",
            "\tstd::vector<E> lazy;",
            "\tT def;",
            "\tE lazy_def;",
            "\tint n, height;",
            "\tLazySegmentTree(int n_, T def, E lazy_def): def(def), lazy_def(lazy_def){",
            "\t\tinit(n_);",
            "\t}",
            "\tLazySegmentTree(const std::vector<T> &v, T def, E lazy_def): def(def), lazy_def(lazy_def){",
            "\t\tint n_ = v.size();",
            "\t\tinit(n_);",
            "\t\tfor(int i=0; i<n_; i++) data[n+i] = v[i];",
            "\t\tfor(int i=n-1; i; i--) data[i] = merge(data[(i<<1)], data[(i<<1)|1]);",
            "\t}",
            "\tvoid init(int n_){",
            "\t\tn=1; height=0;",
            "\t\twhile(n<n_) n<<=1, height++;",
            "\t\tdata.assign(2*n, def);",
            "\t\tlazy.assign(2*n, lazy_def);",
            "\t}",
            "\tT reflect(int k){",
            "\t\treturn lazy[k]==lazy_def?data[k]:apply(data[k], lazy[k]);",
            "\t}",
            "\tvoid eval(int k){",
            "\t\tif(lazy[k]==lazy_def) return;",
            "\t\tlazy[k<<1] = propagate(lazy[k<<1], lazy[k]);",
            "\t\tlazy[(k<<1)|1] = propagate(lazy[(k<<1)|1], lazy[k]);",
            "\t\tdata[k] = reflect(k);",
            "\t\tlazy[k] = lazy_def;",
            "\t}",
            "\tvoid thrust(int k){",
            "\t\tfor(int i=height; i; i--) eval(k>>i);",
            "\t}",
            "\tvoid recalc(int k){",
            "\t\twhile(k>>=1) data[k] = merge(reflect(k<<1), reflect((k<<1)|1));",
            "\t}",
            "\tvoid update(int a, int b, E x){",
            "\t\tthrust(a+=n);",
            "\t\tthrust(b+=n-1);",
            "\t\tfor(int l=a, r=b+1; l<r; l>>=1, r>>=1){",
            "\t\t\tif(l&1) lazy[l] = propagate(lazy[l], x), l++;",
            "\t\t\tif(r&1) --r, lazy[r]=propagate(lazy[r], x);",
            "\t\t}",
            "\t\trecalc(a);",
            "\t\trecalc(b);",
            "\t}",
            "\tvoid set(int a, T x){",
            "\t\tthrust(a+=n);",
            "\t\tdata[a] = x;",
            "\t\tlazy[a] = lazy_def;",
            "\t\trecalc(a);",
            "\t}",
            "\tT query(int a, int b){",
            "\t\tthrust(a+=n);",
            "\t\tthrust(b+=n-1);",
            "\t\tT vl = def, vr = def;",
            "\t\tfor(int l=a, r=b+1; l<r; l>>=1, r>>=1){",
            "\t\t\tif(l&1) vl = merge(vl, reflect(l++));",
            "\t\t\tif(r&1) vr = merge(reflect(--r), vr);",
            "\t\t}",
            "\t\treturn merge(vl, vr);",
            "\t}",
            "",
            "\t// Example (min, add)",
            "\tT merge(T left, T right) const { return std::min(left, right); }",
            "\tE propagate(E before, E change) const { return before+change; }",
            "\tT apply(T val, E laz) const { return val+laz; }",
            "};"
        ],
        "description": "cpp/lazy_segment_tree.cpp"
    },
    "divisors.cpp": {
        "prefix": "divisors.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "// list all divisors of n. O(sqrt(n))",
            "std::vector<long long> get_divisors(long long n){",
            "\tstd::vector<long long> div(1, 1);",
            "\tfor(int i=2; (long long)i*i<=n; i++){",
            "\t\tif(n%i==0) div.push_back(i);",
            "\t}",
            "\tfor(int i=div.size()-1; i>=0; i--){",
            "\t\tif(div[i]*div[i]==n) continue;",
            "\t\tdiv.push_back(n/div[i]);",
            "\t}",
            "\treturn div;",
            "}"
        ],
        "description": "cpp/divisors.cpp"
    },
    "toposort.cpp": {
        "prefix": "toposort.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "typedef std::vector<std::vector<std::pair<int, long long>>> Graph;",
            "",
            "/*",
            "\tTopological sort.",
            "\tIf graph is not a DAG, return empty list.",
            "*/",
            "std::vector<int> toposort(Graph &graph) {",
            "\tint n = graph.size();",
            "\tstd::vector<int> order;",
            "\tstd::vector<bool> done(n), visit(n);",
            "\tfor(int i=0; i<n; i++){",
            "\t\tif(done[i]) continue;",
            "\t\tif(toposort_rec(i, graph, visit, done, order)){",
            "\t\t\treturn std::vector<int>();",
            "\t\t}",
            "\t}",
            "\treverse(order.begin(), order.end());",
            "\treturn order;",
            "}",
            "",
            "bool toposort_rec(int u, Graph &g, std::vector<bool> &visit, std::vector<bool> &done, std::vector<int> &order) {",
            "\tif(visit[u]) return true;",
            "\tif(done[u]) return false;",
            "\tdone[u] = visit[u] = true;",
            "\tfor(auto v: g[u]){",
            "\t\tif(toposort_rec(v.first, g, visit, done, order)) return true;",
            "\t}",
            "\tvisit[u]=false;",
            "\torder.push_back(u);",
            "\treturn false;",
            "}"
        ],
        "description": "cpp/toposort.cpp"
    },
    "convolution.cpp": {
        "prefix": "convolution.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "// Extended Euclid's greatest common divisor algorithm",
            "// Find (x, y)",
            "// where",
            "//   - a*x + b*y = gcd(a, b)$",
            "long long ext_gcd(long long a, long long b, long long &x, long long &y){",
            "\tif(b == 0){",
            "\t\tx = 1; y = 0; return a;",
            "\t}",
            "\tlong long nx, ny;",
            "\tlong long g = ext_gcd(b, a%b, nx, ny);",
            "\tx = ny;",
            "\ty = nx - a / b * ny;",
            "\treturn g;",
            "}",
            "",
            "template<long long m=1000000007>",
            "struct modint {",
            "\ttypedef long long ll;",
            "\tll x;",
            "\tstatic constexpr ll mod() { return m; }",
            "\tconstexpr modint(ll x=0): x((m+x%m)%m) {}",
            "\tmodint<m> operator-() const { return modint(m-x); }",
            "\tmodint<m>& operator+=(const modint<m> o) { x=(x+o.x)%m; return *this; }",
            "\tmodint<m>& operator+=(const ll o) { return (*this)+=modint(o); }",
            "\tmodint<m>& operator-=(const modint<m> o) { return (*this)+=(-o); }",
            "\tmodint<m>& operator-=(const ll o) { return (*this)-=modint(o); }",
            "\tmodint<m>& operator*=(const modint<m> o) { x = x*o.x%m; return *this; }",
            "\tmodint<m>& operator*=(const ll o) { return (*this)*=modint(o); }",
            "\tmodint<m>& operator/=(const modint<m> o) { return (*this)*=o.inv(); }",
            "\tmodint<m>& operator/=(const ll o) { return (*this)/=modint(o); }",
            "\tfriend modint<m> operator+(modint<m> l, const modint<m> r) { l+=r; return l; }",
            "\tfriend modint<m> operator+(modint<m> l, const ll r) { l+=r; return l; }",
            "\tfriend modint<m> operator+(const ll l, modint<m> r) { r+=l; return r; }",
            "\tfriend modint<m> operator-(modint<m> l, const modint<m> r) { l-=r; return l; }",
            "\tfriend modint<m> operator-(modint<m> l, const ll r) { l-=r; return l; }",
            "\tfriend modint<m> operator-(const ll l, modint<m> r) { r*=-1; r+=l; return r; }",
            "\tfriend modint<m> operator*(modint<m> l, const modint<m> r) { l*=r; return l; }",
            "\tfriend modint<m> operator*(modint<m> l, const ll r) { l*=r; return l; }",
            "\tfriend modint<m> operator*(const ll l, modint<m> r) { r*=l; return r; }",
            "\tfriend modint<m> operator/(modint<m> l, const modint<m> r) { l/=r; return l; }",
            "\tfriend modint<m> operator/(modint<m> l, const ll r) { l/=r; return l; }",
            "\tfriend modint<m> operator/(const ll l, const modint<m> r) { return modint(l)/r; }",
            "\tbool operator==(const modint<m> o) const { return x==o.x; }",
            "\tbool operator!=(const modint<m> o) const { return x!=o.x; }",
            "\tfriend bool operator==(const ll l, const modint<m> r) { return modint<m>(l) == r; }",
            "\tfriend bool operator!=(const ll l, const modint<m> r) { return modint<m>(l) != r; }",
            "\tfriend std::ostream& operator<<(std::ostream &os, const modint<m> x) { return os << x.x; }",
            "",
            "\tmodint<m> pow(ll k) const {",
            "\t\tif(k==0) return modint<m>(1);",
            "\t\tif(k%2) return pow(k-1)*x;",
            "\t\tmodint<m> z = pow(k/2); return z*z;",
            "\t}",
            "",
            "\tmodint<m> inv() const {",
            "\t\tll y,z;",
            "\t\text_gcd(x, m, y, z);",
            "\t\treturn modint<m>(y);",
            "\t}",
            "};",
            "",
            "using mint = modint<>;",
            "",
            "template<typename mint = mint>",
            "struct Comb {",
            "\ttypedef long long ll;",
            "\tconst ll m = mint::mod();",
            "\tstd::vector<mint> fact, fact_inv;",
            "\tComb(int n_max=2000005) {",
            "\t\tfact.assign(n_max, 0);",
            "\t\tfact_inv.assign(n_max, 0);",
            "\t\tfact[0] = 1;",
            "\t\tfact_inv[0] = 1;",
            "\t\tfor(int i=1; i<std::min((ll)n_max, m); i++){",
            "\t\t\tfact[i] = fact[i-1] * i;",
            "\t\t\tfact_inv[i] = fact[i].inv();",
            "\t\t}",
            "\t}",
            "\tmint operator() (ll n, ll k) const {",
            "\t\tif(n < m){",
            "\t\t\treturn fact[n] * fact_inv[k] * fact_inv[n-k];",
            "\t\t} else {",
            "\t\t\treturn comb_ext(n, k);",
            "\t\t}",
            "\t}",
            "",
            "// Modular factorial of n, also counting p's appearance e",
            "// n! = a * p^e",
            "// return: a % p",
            "// n! = n * (n-1) * ... * (k*p+1) *",
            "//      (k*p) * (k*p-1) * ... ((k-1)*p+1) *",
            "//      ...",
            "//      p * (p-1) * ... * 2 * 1   (k = floor(n/p))",
            "//    = (n%p) * ... * 1 *",
            "//      (k*p) * (p-1) * ... * 1 *",
            "//      p * (p-1) * ... * 1       (mod p, preserving p's multiples)",
            "//    = (n%p)! * p^k * k! * (p-1)^k",
            "//    = (n%p)! * p^k * k! * (p-1)^(k%2)",
            "//",
            "// From the facts:",
            "//   (p-1)! = p-1 (mod p) (c.f. Willson's theorem)",
            "//   (p-2)**2 = 1 (mod p)",
            "\tmint fact_ext(ll n, ll &e) const {",
            "\t\tif(n == 0){",
            "\t\t\te = 0;",
            "\t\t\treturn mint(1);",
            "\t\t}",
            "",
            "\t\tmint na = fact_ext(n/m, e);",
            "\t\te += n/m;",
            "\t\tmint a = na * fact[n%m];",
            "\t\tif((n/m)%2) a = a * (m-1);",
            "\t\treturn a;",
            "\t}",
            "",
            "// Modular combination (n, m) given module p",
            "// (n, m) = n!/(n-m)!m!",
            "//        = (a_n * p^(e_n)) / ((a_{n-m} * p^(e_{n-m}) * (a_m * p^e_m))",
            "//        = a_n / (a_{n-m} * a_m) * p^(e_n - e_{n-m} - e_m)",
            "\tmint comb_ext (ll n, ll k) const {",
            "\t\tll e1,e2,e3;",
            "\t\tmint a1 = fact_ext(n, e1);",
            "\t\tmint a2 = fact_ext(k, e2);",
            "\t\tmint a3 = fact_ext(n-k, e3);",
            "",
            "\t\tif(e1 > e2+e3) return 0;",
            "\t\telse return a1*(a2*a3).inv();",
            "\t}",
            "};",
            "",
            "constexpr long long pow_mod(long long x, long long n, int m) {",
            "    if(m==1) return 0;",
            "    unsigned int um = m;",
            "    long long y = ((x%um)+um)%um;",
            "    unsigned long long r = 1;",
            "    while(n){",
            "        if(n&1) r = r*y%um;",
            "        y = y*y%um;",
            "        n >>= 1;",
            "    }",
            "    return r;",
            "}",
            "",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "    a = (a%b+b)%b;",
            "    if (a == 0) return {b, 0};",
            "",
            "    // Contracts:",
            "    // [1] s - m0 * a = 0 (mod b)",
            "    // [2] t - m1 * a = 0 (mod b)",
            "    // [3] s * |m1| + t * |m0| <= b",
            "    long long s = b, t = a;",
            "    long long m0 = 0, m1 = 1;",
            "",
            "    while (t) {",
            "        long long u = s / t;",
            "        s -= t * u;",
            "        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b",
            "",
            "        // [3]:",
            "        // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "        // = s * |m1| + t * |m0| <= b",
            "",
            "        auto tmp = s;",
            "        s = t;",
            "        t = tmp;",
            "        tmp = m0;",
            "        m0 = m1;",
            "        m1 = tmp;",
            "    }",
            "    // by [3]: |m0| <= b/g",
            "    // by g != b: |m0| < b/g",
            "    if (m0 < 0) m0 += b / s;",
            "    return {s, m0};",
            "}",
            "",
            "constexpr int find_primitive_root(int m){",
            "    if(m==2) return 1;",
            "    if(m==167772161) return 3;",
            "    if(m==469762049) return 3;",
            "    if(m==754974721) return 11;",
            "    if(m==998244353) return 3;",
            "",
            "    int divs[20] = {};",
            "    divs[0] = 2;",
            "    int cnt = 1;",
            "    int x = (m-1)/2;",
            "    while(x%2==0) x /= 2;",
            "    for(int i=3; (long long)(i)*i<=x; i+=2){",
            "        if(x%i==0){",
            "            divs[cnt++] = i;",
            "            while(x%i==0){",
            "                x /= i;",
            "            }",
            "        }",
            "    }",
            "    if(x>1){",
            "        divs[cnt++] = x;",
            "    }",
            "    for(int g=2;; g++){",
            "        bool ok = true;",
            "        for(int i=0; i<cnt; i++){",
            "            if (pow_mod(g, (m - 1) / divs[i], m) == 1) {",
            "                ok = false;",
            "                break;",
            "            }",
            "        }",
            "        if (ok) return g;",
            "    }",
            "}",
            "",
            "template<long long m>",
            "constexpr modint<m> primitive_root = modint<m>(find_primitive_root(m));",
            "",
            "int bsf(unsigned long long x){",
            "    return __builtin_ctz(x);",
            "}",
            "",
            "int ceil_log2(unsigned long long x){",
            "    int n = 0;",
            "    while((1ULL<<n)<x) n++;",
            "    return n;",
            "}",
            "",
            "template<typename mint>",
            "void fft(std::vector<mint> &f) {",
            "    static constexpr mint g = primitive_root<mint::mod()>;",
            "    int n = f.size();",
            "    int h = ceil_log2(n);",
            "    assert(1<<h == n);",
            "",
            "    static bool init = false;",
            "    static mint sum_e[30];",
            "    if(!init){",
            "        init = true;",
            "        mint es[30], ies[30];",
            "        int cnt2 = bsf(mint::mod() - 1);",
            "        assert(cnt2 >= h);",
            "        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();",
            "        for (int i = cnt2; i >= 2; i--) {",
            "            // e^(2^i) == 1",
            "            es[i - 2] = e;",
            "            ies[i - 2] = ie;",
            "            e *= e;",
            "            ie *= ie;",
            "        }",
            "        mint now = 1;",
            "        for (int i = 0; i <= cnt2 - 2; i++) {",
            "            sum_e[i] = es[i] * now;",
            "            now *= ies[i];",
            "        }",
            "    }",
            "    for (int ph = 1; ph <= h; ph++) {",
            "        int w = 1 << (ph - 1), p = 1 << (h - ph);",
            "        mint now = 1;",
            "        for (int s = 0; s < w; s++) {",
            "            int offset = s << (h - ph + 1);",
            "            for (int i = 0; i < p; i++) {",
            "                auto l = f[i + offset];",
            "                auto r = f[i + offset + p] * now;",
            "                f[i + offset] = l + r;",
            "                f[i + offset + p] = l - r;",
            "            }",
            "            now *= sum_e[bsf(~(unsigned int)(s))];",
            "        }",
            "    }",
            "}",
            "",
            "template <typename mint>",
            "void ifft(std::vector<mint> &f) {",
            "    static constexpr mint g = primitive_root<mint::mod()>;",
            "    int n = int(f.size());",
            "    int h = ceil_log2(n);",
            "    assert(1<<h == n);",
            "",
            "    static bool init = false;",
            "    static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]",
            "    if (!init) {",
            "        init = true;",
            "        mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1",
            "        int cnt2 = bsf(mint::mod() - 1);",
            "        mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();",
            "        for (int i = cnt2; i >= 2; i--) {",
            "            // e^(2^i) == 1",
            "            es[i - 2] = e;",
            "            ies[i - 2] = ie;",
            "            e *= e;",
            "            ie *= ie;",
            "        }",
            "        mint now = 1;",
            "        for (int i = 0; i <= cnt2 - 2; i++) {",
            "            sum_ie[i] = ies[i] * now;",
            "            now *= es[i];",
            "        }",
            "    }",
            "",
            "    for (int ph = h; ph >= 1; ph--) {",
            "        int w = 1 << (ph - 1), p = 1 << (h - ph);",
            "        mint inow = 1;",
            "        for (int s = 0; s < w; s++) {",
            "            int offset = s << (h - ph + 1);",
            "            for (int i = 0; i < p; i++) {",
            "                auto l = f[i + offset];",
            "                auto r = f[i + offset + p];",
            "                f[i + offset] = l + r;",
            "                f[i + offset + p] =",
            "                    (unsigned long long)(mint::mod() + l.x - r.x) *",
            "                    inow.x;",
            "            }",
            "            inow *= sum_ie[bsf(~(unsigned int)(s))];",
            "        }",
            "    }",
            "",
            "    mint z = mint(1<<h).inv();",
            "    for(int i=0; i<f.size(); i++){",
            "        f[i] *= z;",
            "    }",
            "}",
            "",
            "template<typename mint>",
            "std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b){",
            "    int n = a.size(), m = b.size();",
            "    if(std::min(n, m)<=60){",
            "        if(n<m){",
            "            std::swap(n, m);",
            "            std::swap(a, b);",
            "        }",
            "        std::vector<mint> ans(n+m-1);",
            "        for(int i=0; i<n; i++){",
            "            for(int j=0; j<m; j++){",
            "                ans[i+j] += a[i] * b[j];",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    int z = 1 << ceil_log2(n+m-1);",
            "    a.resize(z);",
            "    b.resize(z);",
            "    fft(a);",
            "    fft(b);",
            "    for(int i=0; i<z; i++) a[i] *= b[i];",
            "    ifft(a);",
            "    a.resize(n+m-1);",
            "    return a;",
            "}",
            "",
            "template<long long mod = 998244353>",
            "std::vector<long long> convolution(std::vector<long long> a, std::vector<long long> b){",
            "    using mi = modint<mod>;",
            "    std::vector<mi> a2(a.size()), b2(b.size());",
            "    for(int i=0; i<a.size(); i++) a2[i] = mi(a[i]);",
            "    for(int i=0; i<b.size(); i++) b2[i] = mi(b[i]);",
            "",
            "    auto c2 = convolution(move(a2), move(b2));",
            "    int n = a.size() + b.size() - 1;",
            "    std::vector<long long> c(n);",
            "    for(int i=0; i<n; i++){",
            "        c[i] = c2[i].x;",
            "    }",
            "    return c;",
            "}",
            "",
            "std::vector<long long> convolution_ll(const std::vector<long long>& a,",
            "                                      const std::vector<long long>& b) {",
            "    int n = a.size(), m = b.size();",
            "    if (!n || !m) return {};",
            "",
            "    static constexpr unsigned long long MOD1 = 754974721;  // 2^24",
            "    static constexpr unsigned long long MOD2 = 167772161;  // 2^25",
            "    static constexpr unsigned long long MOD3 = 469762049;  // 2^26",
            "    static constexpr unsigned long long M2M3 = MOD2 * MOD3;",
            "    static constexpr unsigned long long M1M3 = MOD1 * MOD3;",
            "    static constexpr unsigned long long M1M2 = MOD1 * MOD2;",
            "    static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;",
            "",
            "    static constexpr unsigned long long i1 = inv_gcd(MOD2 * MOD3, MOD1).second;",
            "    static constexpr unsigned long long i2 = inv_gcd(MOD1 * MOD3, MOD2).second;",
            "    static constexpr unsigned long long i3 = inv_gcd(MOD1 * MOD2, MOD3).second;",
            "",
            "    auto c1 = convolution<MOD1>(a, b);",
            "    auto c2 = convolution<MOD2>(a, b);",
            "    auto c3 = convolution<MOD3>(a, b);",
            "",
            "    std::vector<long long> c(n + m - 1);",
            "    for (int i = 0; i < n + m - 1; i++) {",
            "        unsigned long long x = 0;",
            "        x += (c1[i] * i1) % MOD1 * M2M3;",
            "        x += (c2[i] * i2) % MOD2 * M1M3;",
            "        x += (c3[i] * i3) % MOD3 * M1M2;",
            "        // B = 2^63, -B <= x, r(real value) < B",
            "        // (x, x - M, x - 2M, or x - 3M) = r (mod 2B)",
            "        // r = c1[i] (mod MOD1)",
            "        // focus on MOD1",
            "        // r = x, x - M', x - 2M', x - 3M' (M' = M % 2^64) (mod 2B)",
            "        // r = x,",
            "        //     x - M' + (0 or 2B),",
            "        //     x - 2M' + (0, 2B or 4B),",
            "        //     x - 3M' + (0, 2B, 4B or 6B) (without mod!)",
            "        // (r - x) = 0, (0)",
            "        //           - M' + (0 or 2B), (1)",
            "        //           -2M' + (0 or 2B or 4B), (2)",
            "        //           -3M' + (0 or 2B or 4B or 6B) (3) (mod MOD1)",
            "        // we checked that",
            "        //   ((1) mod MOD1) mod 5 = 2",
            "        //   ((2) mod MOD1) mod 5 = 3",
            "        //   ((3) mod MOD1) mod 5 = 4",
            "        long long M1 = MOD1;",
            "        long long diff =",
            "            c1[i] - ((long long)(x)%M1+M1)%M1;",
            "        if (diff < 0) diff += MOD1;",
            "        static constexpr unsigned long long offset[5] = {",
            "            0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};",
            "        x -= offset[diff % 5];",
            "        c[i] = x;",
            "    }",
            "",
            "    return c;",
            "}"
        ],
        "description": "cpp/convolution.cpp"
    },
    "lowlink.cpp": {
        "prefix": "lowlink.cpp",
        "scope": "cpp",
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "struct LowLink {",
            "\tint n;",
            "\tstd::vector<std::vector<int>> graph;",
            "\tstd::vector<int> used, ord, low;",
            "\tstd::vector<bool> articulation;",
            "\tstd::set<std::pair<int, int>> bridge;",
            "",
            "\tLowLink(int n): n(n) {",
            "\t\tgraph.assign(n, {});",
            "\t}",
            "\tvoid add_edge(int u, int v){",
            "\t\tgraph[u].push_back(v);",
            "\t\tgraph[v].push_back(u);",
            "\t}",
            "\tint dfs(int u, int p, int k) {",
            "\t\tused[u] = true;",
            "\t\tord[u] = k++;",
            "\t\tlow[u] = ord[u];",
            "\t\tint cnt = 0;",
            "\t\tfor(int v : graph[u]) {",
            "\t\t\tif(!used[v]) {",
            "\t\t\t\t++cnt;",
            "\t\t\t\tk = dfs(v, u, k);",
            "\t\t\t\tlow[u] = std::min(low[u], low[v]);",
            "\t\t\t\tarticulation[u] = articulation[u] ||(~p && low[v] >= ord[u]);",
            "\t\t\t\tif(ord[u] < low[v]) bridge.insert(std::minmax(u, v));",
            "\t\t\t} else if(v != p) {",
            "\t\t\t\tlow[u] = std::min(low[u], ord[v]);",
            "\t\t\t}",
            "\t\t}",
            "\t\tarticulation[u] = articulation[u] || (p == -1 && cnt > 1);",
            "\t\treturn k;",
            "\t}",
            "\tvoid build() {",
            "\t\tused.assign(n, 0);",
            "\t\tord.assign(n, 0);",
            "\t\tlow.assign(n, 0);",
            "\t\tarticulation.assign(n, false);",
            "\t\tint k = 0;",
            "\t\tfor(int i = 0; i < n; i++) {",
            "\t\t\tif(!used[i]) k = dfs(i, -1, k);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "cpp/lowlink.cpp"
    }
}